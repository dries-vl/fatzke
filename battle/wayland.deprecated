#ifdef __linux__
#include "header.h"

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// sudo apt install libwayland-dev (for getting the wayland-client header and lib)
#include <wayland-client.h>
// sudo apt install wayland-protocols wayland-scanner (for generating the xdg-shell files)
// sudo wayland-scanner client-header /usr/share/wayland-protocols/stable/xdg-shell/xdg-shell.xml /usr/include/xdg-shell-client-protocol.h
// sudo wayland-scanner private-code /usr/share/wayland-protocols/stable/xdg-shell/xdg-shell.xml /usr/include/xdg-shell-client-protocol.c
#include <xdg-shell-client-protocol.h>
#include <xdg-shell-client-protocol.c>
// sudo wayland-scanner client-header /usr/share/wayland-protocols/stable/presentation-time/presentation-time.xml /usr/include/presentation-time-client-protocol.h
// sudo wayland-scanner private-code /usr/share/wayland-protocols/stable/presentation-time/presentation-time.xml /usr/include/presentation-time-client-protocol.c
#include <presentation-time-client-protocol.h>
#include <presentation-time-client-protocol.c>
// sudo wayland-scanner client-header /usr/share/wayland-protocols/stable/presentation-time/presentation-time.xml /usr/include/drm-lease-v1-client-protocol.h
// sudo wayland-scanner private-code /usr/share/wayland-protocols/stable/presentation-time/presentation-time.xml /usr/include/drm-lease-v1-client-protocol.c
#include <drm-lease-v1-client-protocol.h>
#include <drm-lease-v1-client-protocol.c>


u64 now_ns(void){ struct timespec ts; clock_gettime(CLOCK_MONOTONIC,&ts); return (u64)ts.tv_sec*1000000000ull+ts.tv_nsec; }
u64 T0;
void pf_time_reset() {T0=now_ns();}
void pf_timestamp(char *msg) {u64 _t=now_ns(); fprintf(stderr,"[+%7.3f ms] %s\n",(_t-T0)/1e6,(msg));}

struct wayland_window {
    /* Wayland core */
    struct wl_display* display;
    struct wl_surface* surface;
    struct wl_compositor* compositor;
    struct xdg_wm_base* xdg_wm_base;
    struct xdg_surface* xdg_surface;
    struct xdg_toplevel* xdg_toplevel;
    struct wp_presentation* presentation;  /* global */

    /* Input */
    struct wl_seat* seat;
    struct wl_keyboard* kbd;
    struct wl_pointer* ptr;

    /* State */
    i32 win_w, win_h;
    i32 mouse_x, mouse_y;

    bool vsync_ready;
    int discard_streak;                    /* consecutive discarded frames */
    bool active;                           /* xdg_toplevel state (ACTIVATED) */
    bool minimized;                        /* configure(0,0) convention */

    /* App callbacks */
    keyboard_cb on_key;
    mouse_cb on_mouse;
    void *callback_data;
};

/* ---------------- wl_keyboard callbacks ---------------- */
void kb_keymap(void* data, struct wl_keyboard* k, u32 format, i32 fd, u32 size) { (void)data;(void)k;(void)format;(void)fd;(void)size; }
void kb_enter(void* data, struct wl_keyboard* k, u32 serial, struct wl_surface* surface, struct wl_array* keys) { (void)data;(void)k;(void)serial;(void)surface;(void)keys; }
void kb_leave(void* data, struct wl_keyboard* k, u32 serial, struct wl_surface* surface) { (void)data;(void)k;(void)serial;(void)surface; }
void kb_key(void* data, struct wl_keyboard* k, u32 serial, u32 time, u32 key, u32 state){
    (void)k;(void)serial;(void)time;
    struct wayland_window* w = (struct wayland_window*)data;
    enum KEYBOARD_BUTTON button = KEYBOARD_BUTTON_UNKNOWN;
    if (key == 1) button = KEYBOARD_ESCAPE;
    if (w && w->on_key) w->on_key(w->callback_data, button, state);
}
void kb_modifiers(void* data, struct wl_keyboard* k, u32 serial, u32 dep, u32 lat, u32 lock, u32 group){ (void)data;(void)k;(void)serial;(void)dep;(void)lat;(void)lock;(void)group; }
void kb_repeat_info(void* data, struct wl_keyboard* k, i32 rate, i32 delay){ (void)data;(void)k;(void)rate;(void)delay; }

const struct wl_keyboard_listener* get_kb_listener(void){
    static const struct wl_keyboard_listener kb_l = {
        .keymap = kb_keymap,
        .enter = kb_enter,
        .leave = kb_leave,
        .key = kb_key,
        .modifiers = kb_modifiers,
        .repeat_info = kb_repeat_info
    };
    return &kb_l;
}

/* ---------------- wl_pointer callbacks ---------------- */
void ptr_enter(void* d, struct wl_pointer* p, u32 serial, struct wl_surface* s, wl_fixed_t sx, wl_fixed_t sy){
    (void)p;(void)serial;(void)s;
    struct wayland_window* w = (struct wayland_window*)d;
    if (!w) return;
    w->mouse_x = wl_fixed_to_int(sx);
    w->mouse_y = wl_fixed_to_int(sy);
    if (w->on_mouse) w->on_mouse(w->callback_data, w->mouse_x, w->mouse_y, MOUSE_MOVED, 0u);
}
void ptr_leave(void* d, struct wl_pointer* p, u32 serial, struct wl_surface* s){ (void)d;(void)p;(void)serial;(void)s; }
void ptr_motion(void* d, struct wl_pointer* p, u32 time, wl_fixed_t sx, wl_fixed_t sy){
    (void)p;(void)time;
    struct wayland_window* w = (struct wayland_window*)d;
    if (!w) return;
    w->mouse_x = wl_fixed_to_int(sx);
    w->mouse_y = wl_fixed_to_int(sy);
    if (w->on_mouse) w->on_mouse(w->callback_data, w->mouse_x, w->mouse_y, MOUSE_MOVED, 0u);
}
void ptr_button(void* d, struct wl_pointer* p, u32 serial, u32 time, u32 button, u32 state){
    (void)p;(void)serial;(void)time;
    struct wayland_window* w = (struct wayland_window*)d;
    if (!w) return;
    u32 mb = MOUSE_BUTTON_UNKNOWN;
    if (button == 272) mb = MOUSE_LEFT;
    if (button == 273) mb = MOUSE_RIGHT;
    if (button == 274) mb = MOUSE_MIDDLE;
    if (w->on_mouse) w->on_mouse(w->callback_data, w->mouse_x, w->mouse_y, mb, state);
}
void ptr_axis(void* d, struct wl_pointer* p, u32 time, u32 axis, wl_fixed_t value){ (void)d;(void)p;(void)time;(void)axis;(void)value; }
void ptr_frame(void* d, struct wl_pointer* p){ (void)d;(void)p; }
void ptr_axis_source(void* d, struct wl_pointer* p, u32 source){ (void)d;(void)p;(void)source; }
void ptr_axis_stop(void* d, struct wl_pointer* p, u32 time, u32 axis){ (void)d;(void)p;(void)time;(void)axis; }
void ptr_axis_discrete(void* d, struct wl_pointer* p, u32 axis, i32 discrete){ (void)d;(void)p;(void)axis;(void)discrete; }
void ptr_axis_value120(void* d, struct wl_pointer* p, u32 axis, i32 value120){ (void)d;(void)p;(void)axis;(void)value120; }
void ptr_axis_relative_direction(void* d, struct wl_pointer* p, u32 axis, u32 direction){ (void)d;(void)p;(void)axis;(void)direction; }

const struct wl_pointer_listener* get_ptr_listener(void){
    static const struct wl_pointer_listener ptr_l = {
        .enter = ptr_enter,
        .leave = ptr_leave,
        .motion = ptr_motion,
        .button = ptr_button,
        .axis = ptr_axis,
        .frame = ptr_frame,
        .axis_source = ptr_axis_source,
        .axis_stop = ptr_axis_stop,
        .axis_discrete = ptr_axis_discrete,
        .axis_value120 = ptr_axis_value120,
        .axis_relative_direction = ptr_axis_relative_direction
    };
    return &ptr_l;
}

/* ---------------- wl_seat callbacks ---------------- */
void seat_capabilities(void* d, struct wl_seat* s, u32 caps){
    struct wayland_window* w = (struct wayland_window*)d;
    if (!w) return;
    if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !w->kbd){
        w->kbd = wl_seat_get_keyboard(s);
        wl_keyboard_add_listener(w->kbd, get_kb_listener(), w);
    }
    if ((caps & WL_SEAT_CAPABILITY_POINTER) && !w->ptr){
        w->ptr = wl_seat_get_pointer(s);
        wl_pointer_add_listener(w->ptr, get_ptr_listener(), w);
    }
}
void seat_name(void* d, struct wl_seat* s, const char* name){ (void)d;(void)s;(void)name; }

const struct wl_seat_listener* get_seat_listener(void){
    static const struct wl_seat_listener seat_l = { .capabilities = seat_capabilities, .name = seat_name };
    return &seat_l;
}

/* ---------------- xdg wm + toplevel ---------------- */
void xdg_ping(void* d, struct xdg_wm_base* b, u32 s){ xdg_wm_base_pong(b, s); }
const struct xdg_wm_base_listener* get_xdg_wm_listener(void){
    static const struct xdg_wm_base_listener l = { .ping = xdg_ping };
    return &l;
}
void top_config(void* d, struct xdg_toplevel* t, i32 w, i32 h, struct wl_array* st){
    struct wayland_window* wdw = (struct wayland_window*)d;
    if (wdw && w > 0 && h > 0){ wdw->win_w = w; wdw->win_h = h; }
}
void top_close(void* d, struct xdg_toplevel* t){ }
void top_bounds(void* d, struct xdg_toplevel* t, i32 w, i32 h){ }
void top_caps(void* d, struct xdg_toplevel* t, struct wl_array* c){ }

const struct xdg_toplevel_listener* get_top_listener(void){
    static const struct xdg_toplevel_listener top_l = {
        .configure = top_config, .close = top_close, .configure_bounds = top_bounds, .wm_capabilities = top_caps
    };
    return &top_l;
}

void xsurf_conf(void* d, struct xdg_surface* s, u32 serial){
    struct wayland_window* w = (struct wayland_window*)d;
    xdg_surface_ack_configure(s, serial);
    if (w){ w->vsync_ready = true; pf_timestamp("xdg_surface configure"); }
}
const struct xdg_surface_listener* get_xsurf_listener(void){
    static const struct xdg_surface_listener xsurf_l = { .configure = xsurf_conf };
    return &xsurf_l;
}

static void surf_enter(void* d, struct wl_surface* s, struct wl_output* o){
}
static void surf_leave(void* d, struct wl_surface* s, struct wl_output* o){ // surface is minimized (alt tab is not enough)
}
static const struct wl_surface_listener* get_surface_listener(void){
    static const struct wl_surface_listener L = { .enter = surf_enter, .leave = surf_leave };
    return &L;
}

/* ---------------- registry ---------------- */
void reg_add(void* d, struct wl_registry* r, uint32_t name, const char* iface, uint32_t ver){
    struct wayland_window* w = d;
    if (!w) return;
    if (!strcmp(iface, wl_compositor_interface.name)){
        u32 v = ver < 4 ? ver : 4; w->compositor = wl_registry_bind(r, name, &wl_compositor_interface, v);
    } else if (!strcmp(iface, xdg_wm_base_interface.name)){
        u32 v = ver < 6 ? ver : 6; w->xdg_wm_base = wl_registry_bind(r, name, &xdg_wm_base_interface, v);
        xdg_wm_base_add_listener(w->xdg_wm_base, get_xdg_wm_listener(), w);
    } else if (!strcmp(iface, wl_seat_interface.name)){
        u32 v = ver < 5 ? ver : 5; w->seat = wl_registry_bind(r, name, &wl_seat_interface, v);
        wl_seat_add_listener(w->seat, get_seat_listener(), w);
    } else if (!strcmp(iface, wp_presentation_interface.name)) {
        /* v1 is fine */
        w->presentation = wl_registry_bind(r, name, &wp_presentation_interface, 1);
    }
}
void reg_rem(void* d, struct wl_registry* r, u32 name){}

const struct wl_registry_listener* get_registry_listener(void){
    static const struct wl_registry_listener reg_l = { .global = reg_add, .global_remove = reg_rem };
    return &reg_l;
}

int pf_window_width(void *w) {
    struct wayland_window* win = w; return win->win_w;
}

int pf_window_height(void *w) {
    struct wayland_window* win = w; return win->win_h;
}

void *pf_surface_or_hwnd(void *w) {
    struct wayland_window* win = w; return win->surface;
}

void *pf_display_or_instance(void *w) {
    struct wayland_window* win = w; return win->display;
}

int pf_window_visible(void *w) {
    struct wayland_window* win = w; return 1;
}

int pf_poll_events(void* win){
    struct wayland_window* w = win;
    if(!w) return 0;
    wl_display_dispatch_pending(w->display);
    wl_display_flush(w->display);
    return 1;
}

void *pf_create_window(void *ud, keyboard_cb key_cb, mouse_cb mouse_cb){
    pf_time_reset();
    struct wayland_window* w = calloc(1, sizeof(*w));
    w->win_w = 0; w->win_h = 0; w->vsync_ready = false;
    w->on_key = key_cb; w->on_mouse = mouse_cb; w->callback_data = ud;

    w->display = wl_display_connect(NULL);
    if (!w->display){ fprintf(stderr, "wl connect failed\n"); exit(1); }
    pf_timestamp("wl_display_connect");

    struct wl_registry* reg = wl_display_get_registry(w->display);
    wl_registry_add_listener(reg, get_registry_listener(), w);
    wl_display_roundtrip(w->display);
    pf_timestamp("wl globals ready");
    if (!w->compositor || !w->xdg_wm_base){ fprintf(stderr, "missing compositor/xdg\n"); exit(1); }


    w->surface  = wl_compositor_create_surface(w->compositor);
    wl_surface_add_listener(w->surface, get_surface_listener(), w);
    w->xdg_surface = xdg_wm_base_get_xdg_surface(w->xdg_wm_base, w->surface);
    xdg_surface_add_listener(w->xdg_surface, get_xsurf_listener(), w);
    w->xdg_toplevel  = xdg_surface_get_toplevel(w->xdg_surface);
    xdg_toplevel_add_listener(w->xdg_toplevel, get_top_listener(), w);
    xdg_toplevel_set_title(w->xdg_toplevel, "tri2");
    xdg_toplevel_set_app_id(w->xdg_toplevel, "tri2");
    xdg_toplevel_set_fullscreen(w->xdg_toplevel, NULL);
    wl_surface_commit(w->surface);
    bool *flag = &w->vsync_ready; // making sure here we've actually gone fullscreen before moving on
    while (!*flag) {
        wl_display_flush(w->display);
        if (wl_display_dispatch(w->display) < 0) exit(1);
    }
    pf_timestamp("wl first commit"); // should be done with all this in ~10ms or less
    return w;
}
#endif
